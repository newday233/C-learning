
一、HASH实现
1、unordered_map 链表法实现 hash表
https://blog.csdn.net/hanzhen7541/article/details/105748755?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-0.pc_relevant_baidujshouduan&spm=1001.2101.3001.4242

假如hash链表太长了影响查询怎么办？
https://blog.csdn.net/xiewenfeng520/article/details/107119970
红黑树查询速度是O(log(n)) 而链表查询速度是O(n)
当hash链表节点大于8的时候就会转为红黑树，为何是8呢，是因为链表长度符合破松分布，8和8以上的概率非常小，红黑树虽然时间效率高了但是牺牲了空间，而且一般如果hashcode比较好的话是很少会出现需要
转换的情况的，也就是说，如果发生了转换，就要去检查下自己的hashcode是否设计正确了。
桶中链表长度小于6时，转回链表。


2、hash 开放地址法
线性探测 一次聚集问题
平方探测 二次聚集问题
双散列
https://blog.csdn.net/weixin_44449616/article/details/108237707


二、指针和引用的区别
1、指针存储一个地址，为指针分配内存地址，指针是一个实体，引用是别名，还是那个东西，不会为引用分配内存地址
2、引用使用时无需解引用（*），指针需要解引用；
3、指针声明时可以不初始化，引用必须初始化
4、可以有空指针，不可以有空引用，所以引用使用时不需要测试其合法性
5、指针可以改变指向，引用不可以
6、引用是类型安全的，而指针不是 (引用比指针多了类型检查）
7、sizeof不同，引用是具体的变量空间，而指针是指针空间
8、自增运算不同，指针++代表指向下一个地址，引用++代表该对象+1
9、可以有多级指针，不能有多级引用（没有引用的引用）
10、引用是操作受限了的指针（仅容许取内容操作）。
